解释器模式（ Interpreter Pattern） 是一种按照规定语法进行解析的方案， 在现在项目中使
用较少， 其定义如下： Given a language, define a representation for its grammar along with an
interpreter that uses the representation to interpret sentences in the language.（ 给定一门语言， 定义
它的文法的一种表示， 并定义一个解释器， 该解释器使用该表示来解释语言中的句子。 ）

场景：

业务需求： 
● 输入一个模型公式（ 加、 减运算） ， 然后输入模型中的参数， 运算出结果。
设计要求：
● 公式可以运行时编辑， 并且符合正常算术书写方式， 例如a+b-c。
● 高扩展性， 未来增加指数、 开方、 极限、 求导等运算符号时较少改动。
● 效率可以不用考虑， 晚间批量运算。

先解释一下为什么需要公式， 而不采用直接计算的方法， 例如有如下3
个公式：
● 业务种类1的公式： a+b+c-d。
● 业务种类2的公式： a+b+e-d。
● 业务种类3的公式： a-f。

其中， a、 b、 c、 d、 e、 f参数的值都可以取得， 如果使用直接计算数值的方法需要为每
个品种写一个算法， 目前仅仅是3个业务种类， 那上百个品种呢？ 歇菜了吧！ 建立公式， 然
后通过公式运算才是王道。

1.	首先，定义一个抽象表达式类Expression，有一个interpreter方法用来解析解析公式和数值
	
2.	接着，定义Expression的子类，变量解析器VarExpression
	仅一个方法interpreter负责对传递进来的参数和值进行解析和匹配， 
	其中输入参数为HashMap类型， key值为模型中的参数， 如a、 b、 c等， value为运算时取得的具	体数字。
	
3.	然后，定义了抽象运算符号解析器SymbolExpression，继承Expression。
	每个运算符号都只和自己左右两个数字有关系， 但左
	右两个数字有可能也是一个解析的结果， 无论何种类型， 都是Expression的实现类， 于是在
	对运算符解析的子类中增加了一个构造函数， 传递左右两个表达式。
	具体的运算符号由SymbolExpression具体的子类完成。例如加法解析器AddExpression和减法解析器SubExpression
	
4.	Calculator的作用是封装， 根据迪米特法则， Client只与直接的朋友Calculator交流， 与其他类没关系。 
5.	此时，Client类可以来模拟用户情况， 用户要求可以扩展， 可以修改公式， 那就通过接收键盘事件来处理。
	
	看， 要求输入一个公式， 然后输入参数， 运行结果出来了！ 那我们是不是可以修改公
	式？ 当然可以， 我们只要输入公式， 然后输入相应的值就可以了， 公式是在运行时定义的，
	而不是在运行前就制定好的， 是不是类似于初中学过的“代数”这门课？ 先公式， 然后赋值，
	运算出结果。
	需求已经开发完毕， 公式可以自由定义， 只要符合规则（ 有变量有运算符合） 就可以运
	算出结果； 若需要扩展也非常容易， 只要增加SymbolExpression的子类就可以了， 这就是解
	释器模式。




优点：
解释器是一个简单语法分析工具， 它最显著的优点就是扩展性， 修改语法规则只要修改
相应的非终结符表达式就可以了， 若扩展语法， 则只要增加非终结符类就可以了。

缺点：
● 解释器模式会引起类膨胀
每个语法都要产生一个非终结符表达式， 语法规则比较复杂时， 就可能产生大量的类文
件， 为维护带来了非常多的麻烦。
● 解释器模式采用递归调用方法
每个非终结符表达式只关心与自己有关的表达式， 每个表达式需要知道最终的结果， 必
须一层一层地剥茧， 无论是面向过程的语言还是面向对象的语言， 递归都是在必要条件下使
用的， 它导致调试非常复杂。 想想看， 如果要排查一个语法错误， 我们是不是要一个断点一
个断点地调试下去， 直到最小的语法单元。
● 效率问题
解释器模式由于使用了大量的循环和递归， 效率是一个不容忽视的问题， 特别是一用于
解析复杂、 冗长的语法时， 效率是难以忍受的。