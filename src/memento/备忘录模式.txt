备忘录模式

备忘录模式（ Memento Pattern） 提供了一种弥补真实世界缺陷的方法， 让“后悔药”在程
序的世界中真实可行， 其定义如下：
（ 在不破坏封装性的前提下， 捕获一个对象的内部状态， 并在该对象之外保存这个状态。 这样以后就可将该对象恢复到原先保存的状态。 ）
通俗地说， 备忘录模式就是一个对象的备份模式， 提供了一种程序数据的备份方法

场景：
1.	追女生，并且可以对状态进行存档，女生不开心的时候读档重新开始
2.	假如只是简单的再new一个Boy对象来记录状态的话，那就等于把Boy的职责交给了Client，破坏了Boy封装性
3.	所以，定义了一个Memento备忘录来记录Boy的状态
4.	此时还不够，因为此时Client类还是要跟备忘录类直接通信，破坏了迪米特法则，对高层模块来说， 它最希望要做的就是创建一个备份点， 然后在需
	要的时候再恢复到这个备份点就成了， 它不用关心到底有没有备忘录这个类。 
5.	那根据这一指导思想， 我们就需要把备忘录类再包装一下， 怎么包装呢？ 建立一个管理类， 就是管理这个备忘录
	也就是定义一个Caretaker，备忘录管理类。
6.	此时的Client，需要备份的时候就创建一个备份， 然后丢给备忘录管理者进行管理， 要取的时候再从管理者手中拿到这个
	备份。 这个备份者就类似于一个备份的仓库管理员， 创建一个丢进去， 需要的时候再拿出来。 这就是备忘录模式。
	
	
备忘录模式的注意事项
● 备忘录的生命期
备忘录创建出来就要在“最近”的代码中使用， 要主动管理它的生命周期， 建立就要使
用， 不使用就要立刻删除其引用， 等待垃圾回收器对它的回收处理。
● 备忘录的性能
不要在频繁建立备份的场景中使用备忘录模式（ 比如一个for循环中） ， 原因有二： 一是
控制不了备忘录建立的对象数量； 二是大对象的建立是要消耗资源的， 系统的性能需要考
虑。 因此， 如果出现这样的代码， 设计师就应该好好想想怎么修改架构了。