定义：用原型实例指定创建对象的种类， 并且通过拷贝这些原型创建新的对象。


原型模式的核心就是克隆：实现Cloneable接口

1. 现在来模拟群发广告邮件的场景。
2. AdvTemplate是广告模板，Mail类是业务对象，Mail类构造函数中传入AdvTemplate对象，邮件标题和内容是模板中获取的。
3. 要防止被当成垃圾邮件，群发的邮件不能完全一样，所以除了标题和context是用模板的，每封邮件的称谓和收件人是不同的，在Client类中体现。
4. 表面上功能实现了，但是实际上存在问题。这是一个线程在运行， 也就是你发送的是单线程的， 那按照一封邮件发出去需要0.02秒（ 够小了， 你
        还要到数据库中取数据呢） ， 600万封邮件需要33个小时， 也就是一个整天都发送不完。
5. 好办， 把sendMail修改为多线程， 但是只把sendMail修改为多线程还是有问题的呀， 产生第一封邮件对象， 放到线程1中运行， 还没有发送出去； 
        线程2也启动了， 直接就把邮件对象mail的收件人地址和称谓修改掉了， 线程不安全了。
6. 关于多线程安全问题，有很多解决办法，其中一种很简单的办法就是使用原型模式：通过对象的复制功能来解决这个问题。
7. 增加了一个Cloneable接口（ Java自带的一个接口） ， Mail实现了这个接口， 在Mail类中覆写clone()方法。
8. 此时，sendMail即使是多线程也没有关系。 注意， 看Client类中的粗体字mail.clone()这个方法， 把对象复制一份， 产生一个新的对象， 和原有对象一样，
        然后再修改细节的数据， 如设置称谓、 设置收件人地址等。 这种不通过new关键字来产生一个对象， 而是通过对象复制来实现的模式就叫做原型模式。
9. 而且，原型模式是在内存二进制流的拷贝， 要比直接new一个对象性能好很多， 特别是要在一个循环体内产生大量的对象时。
        所以，此时程序的执行时间将会快非常多。

优点或缺点：
	这既是它的优点也是缺点， 直接在内存中拷贝， 构造函数是不会执行的（ 参见13.4节） 。 
	优点就是减少了约束， 缺点也是减少了约束， 需要大家在实际应用时考虑。

另外，使用对象的克隆，还要注意浅拷贝和深拷贝。浅拷贝就是默认情况对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址。
也就是被拷贝的和原对象共享了私有变量，这是不安全的。（基础数据类型则会拷贝一份新的）
相对的，深拷贝就是对私有变量进行独立的拷贝：例如，thing.arrayList = (ArrayList<String>)this.arrayList.clone();

最后，final不能clone