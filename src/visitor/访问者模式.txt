访问者模式（ Visitor Pattern） 是一个相对简单的模式， 其定义如下： Represent an
operation to be performed on the elements of an object structure. Visitor lets you define a new
operation without changing the classes of the elements on which it operates. （ 封装一些作用于某种
数据结构中的各元素的操作， 它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。 ）

相当于是，让访问者Visitor到数据结构中取数据，然后Visitor来处理这个数据
这样就可以灵活的定义Visitor来完成对数据的各种处理，数据结构不用改变

场景：
1.	统计公司员工的工资总额
2.	首先，定义抽象员工类Employee，里面定义了员工的基本信息，注意，还有一个accept抽象方法，用来接收访问者
3.	接着，定义普通员工类CommonEmployee和管理层员工类Manager，都继承Employee类
	也就是说，Employee里定义了员工的基本信息，而具体的员工类型的不同信息则由子类来定义，比如CommonEmployee的job和Manager的performance
	并且两个子类都实现了accept方法，接收IVisitor，并调用其visit方法，把数据交给visit
4.	IVisitor是抽象访问者类，定义了可以访问哪些员工的抽象方法，以及getTotalSalary方法
5.	Visitor访问者实现类，visit方法根据传入的是什么类型的员工，调用不同的方法，来计算工资
	这样一来，就可以根据不同的员工类型，乘以不同的工资系数，灵活调整
6.	至此，Client类里，只需要new一个访问者，并且让这个访问者访问一遍所有的员工，取得他们的数据进行处理，就可以得到工资总额
	这样的好处就是，对数据的处理方式可以有多种多样，对于不同的需求，我只要定义新的访问者类来完成这个需求，而不需要去修改源数据



优点：
● 符合单一职责原则
具体元素角色也就是Employee抽象类的两个子类负责数据的加载， 而Visitor类则负责报
表的展现， 两个不同的职责非常明确地分离开来， 各自演绎变化。
● 优秀的扩展性
由于职责分开， 继续增加对数据的操作是非常快捷的， 例如， 现在要增加一份给大老板
的报表， 这份报表格式又有所不同， 直接在Visitor中增加一个方法， 传递数据后进行整理打
印。
● 灵活性非常高
例如， 数据汇总， 就以刚刚我们说的Employee的例子， 如果我现在要统计所有员工的工
资之和， 怎么计算？ 把所有人的工资for循环加一遍？ 是个办法， 那我再提个问题， 员工工资
×1.2， 部门经理×1.4， 总经理×1.8， 然后把这些工资加起来， 你怎么处理？ 1.2， 1.4， 1.8是什
么？ 不是吧？ ！ 你没看到领导不论什么时候都比你拿得多， 工资奖金就不说了， 就是过节发
个慰问券也比你多， 就是这个系数在作祟。 我们继续说你想怎么统计？ 使用for循环， 然后使
用instanceof来判断是员工还是经理？ 这可以解决， 但不是个好办法， 好办法是通过访问者模
式来实现， 把数据扔给访问者， 由访问者来进行统计计算。

缺点：
● 具体元素对访问者公布细节
访问者要访问一个类就必然要求这个类公布一些方法和数据， 也就是说访问者关注了其
他类的内部细节， 这是迪米特法则所不建议的。
● 具体元素变更比较困难
具体元素角色的增加、 删除、 修改都是比较困难的， 就上面那个例子， 你想想， 你要是
想增加一个成员变量， 如年龄age， Visitor就需要修改， 如果Visitor是一个还好办， 多个呢？
业务逻辑再复杂点呢？
● 违背了依赖倒置转原则
访问者依赖的是具体元素， 而不是抽象元素， 这破坏了依赖倒置原则， 特别是在面向对
象的编程中， 抛弃了对接口的依赖， 而直接依赖实现类， 扩展比较难。